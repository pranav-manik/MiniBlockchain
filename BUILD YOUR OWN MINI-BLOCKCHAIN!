BUILD YOUR OWN MINI-BLOCKCHAIN!
Representing Transactions
In this lesson, you'll build a small blockchain of your own in Python! This lesson assumes a familiarity with Python syntax, functions, loops, importing libraries, and constructing classes, but there are some hints along the way to help out. If you've never used Python before, you might want to learn some with Codecademy.

The blockchain is a new way of storing and moving data securely. The data mostly consists of transactions which include messages exchanged between two parties. Before we start creating our blockchain, let's think of a way to store a transaction like the one shown below:

amount: 30
sender: Alice
receiver: Bob

In this example, Alice is trying to transfer 30 units of some currency to Bob. Can you think of a Python data type to best represent the above transaction?

This transaction is best represented in the form of a Python dictionary, with keys for the required fields and values specific to the transaction.

These transactions are all stored inside the mempool, a pool of transactions that miners reference when selecting the set of transactions they want to verify.


1.
Let's create a transaction and add it to the mempool. Name the new transaction my_transaction and add amount, sender, and receiver as key-values.
2.
Add my_transaction to the mempool list.
3.
Create a new list called block_transactions and add three transactions from the mempool list. This will allow us to prepare the transactions to be added to our future Block structure

____________
| script.py |
/******************************************************************************************************/
transaction1 = {
  'amount': '30',
  'sender': 'Alice',
  'receiver': 'Bob'}
transaction2 = { 
  'amount': '200',
  'sender': 'Bob',
  'receiver': 'Alice'}
transaction3 = { 
  'amount': '300',
  'sender': 'Alice',
  'receiver': 'Timothy' }
transaction4 = { 
  'amount': '300',
  'sender': 'Rodrigo',
  'receiver': 'Thomas' }
transaction5 = { 
  'amount': '200',
  'sender': 'Timothy',
  'receiver': 'Thomas' }
transaction6 = { 
  'amount': '400',
  'sender': 'Tiffany',
  'receiver': 'Xavier' }

mempool = [transaction1, transaction2, transaction3, transaction4, transaction5, transaction6]

# add your code below


my_transaction = {'amount':100, 'sender':'elon musk', 'receiver': 'Pranav'}

mempool.append(my_transaction)

block_transactions = [transaction1, transaction3, transaction6]

/******************************************************************************************************/


Creating Blocks
Now let's think of a way to represent a block in Python. We could create a bigger dictionary and store our data inside this dictionary. But since blocks can be represented as objects, let's create a Block Class which we can easily use to create new blocks.

Recall that a Block contains the following properties:

-Timestamp
-Transaction
-Hash
-Previous Hash
-Nonce
In this exercise, we will be creating the default constructor for the Block class in our Mini-Blockchain.
1.
Every Block in the blockchain has a timestamp associated with it. In order to dynamically generate a timestamp, we must import a Python module that returns the current date and time.

Import the datetime module from the datetime library.
2.
Inside the datetime module there is a .now() method that returns the current date and time.

Call the datetime module's .now() method to print out the current date and time.
3.
Now let's work on creating our Block. We will be passing transactions and previous_hash to the default constructor each time a Block is created.

Complete the __init__() method inside the Block class by initializing the following instance variables:

-transactions
-previous_hash
-nonce (with a default value of 0)
4.
Inside the __init__() method, create a timestamp instance variable that stores the current date and time.

____________
| block.py |
/******************************************************************************************************/

# import datetime library
from datetime import datetime

# print current date and time
print(datetime.now())

class Block:
# default constructor for block class
  def __init__(self, transactions, previous_hash, nonce = 0):
    self.transactions = transactions
    self.previous_hash = previous_hash
    self.nonce = nonce
    self.timestamp = datetime.now()

/******************************************************************************************************/

BUILD YOUR OWN MINI-BLOCKCHAIN!
Hashing and SHA-256
Before we create a more dynamic blockchain, let’s learn how to use a hash function in Python. Specifically, we will be using the SHA-256 hash function (https://docs.python.org/2/library/hashlib.html) which can be easily imported in Python.

We will use the SHA-256 as a regular function that takes in a random string as its argument. To properly use this function in Python 3, our string must be encoded before being passed as an argument. To encode the string, we use the .encode() method.
1.
Import sha256 from the hashlib Python library.
2.
Create a variable called text. Initialize the variable with this string "I am excited to learn about blockchain".
3.
Create a sha256 hash object, using the constructor sha256() and pass the text variable as its argument. Assign the value of this object to a variable called hash_result.

Be sure to use the .encode() method on the text variable.

4.
Call the .hexdigest() method on hash_result and print the result.

5.
Modify the text variable by adding an exclamation mark at the end and running your code.

Notice how this hash is completely different from the last one?


____________
| block.py |
/******************************************************************************************************/

# import sha256
from hashlib import sha256

# text to hash
text = "I am excited to learn about blockchain"

hash_result = sha256(text.encode())

# print result
print(hash_result.hexdigest())

/******************************************************************************************************/

Generating Block Hashes
Block hashes are used to uniquely identify and maintain the integrity of each block. The SHA-256 algorithm is used to generate the hash of the block using the timestamp, data, and previous hash — the three properties of our Block class!

Let’s create the .generate_hash() method for the Block class.
1.
In the .generate_hash() method, create the variable block_contents, which combines the Block timestamp, transactions, nonce, and previous hash.

Wrap each item in the str() method in order to convert them to a string type to prepare for hashing.

Return the result.

2.
Create a variable block_hash.

Create a new hash with sha256() and block_contents and save the value to block_hash.

Remember to use the .encode() method to encode the string.

Update the method to return block_hash.
3.
Return the text hash value by calling the hexdigest() method on block_hash.
4.
Uncomment the line in __init__() that calls the generate_hash() function to complete the Block class.

____________
| block.py |
/******************************************************************************************************/

from datetime import datetime
from hashlib import sha256

class Block:
  def __init__(self, transactions, previous_hash, nonce = 0):
    self.timestamp = datetime.now()
    self.transactions = transactions
    self.previous_hash = previous_hash
    self.nonce = nonce
    self.hash = self.generate_hash()
    
  def print_block(self):
    # prints block contents
    print("timestamp:", self.timestamp)
    print("transactions:", self.transactions)
    print("current hash:", self.generate_hash())
    
  def generate_hash(self):
    # hash the blocks contents
    block_contents = str(self.timestamp) + str(self.transactions) + str(self.previous_hash) + str(self.nonce)
    block_hash = sha256(block_contents.encode())
    return block_hash.hexdigest()


/******************************************************************************************************/


Creating the Blockchain Class
Each computer participant has their own copy of the blockchain. Ideally, each copy of the blockchain should have the same properties and functionality to add and validate blocks.

We can represent the blockchain as an object. We are using objects for our implementation, because they offer the flexibility to create specific attributes and methods. Representing it as an object also allows us to create blockchain instances for each computer participant.

To review, our blockchain contains the following:

Chain: A list that that holds all the blocks inside the blockchain.
Unverified Transactions: A list that represents all the unverified transactions before being passed into a block.
Genesis Block: A block automatically generated when the blockchain is initialized.
1.
Fill in the __init__() method inside the Blockchain class by initializing instance variables chain and all_transactions as empty Python lists.
2.
Complete the method genesis_block by instantiating a new Block object with an empty transactions list and a hash of 0.

Append the resulting block to the chain.

3.
Since we want to automatically create a Genesis Block when a new blockchain object is created, call the method .genesis_block() inside the __init__() method

_________________
| blockchain.py |
/******************************************************************************************************/

#imports the Block class from block.py
from block import Block

class Blockchain:
    def __init__(self):
      self.chain = []
      self.all_transactions = []
      self.genesis_block()
    
    def genesis_block(self):
      transactions = {}
      previous_hash = "0"
      self.chain.append(Block(transactions, previous_hash))


/******************************************************************************************************/
_________________
| block.py |
/******************************************************************************************************/

import datetime
from hashlib import sha256

class Block:
  def __init__(self, transactions, previous_hash):
    self.timestamp = datetime.datetime.now()
    self.transactions = transactions
    self.previous_hash = previous_hash
    self.hash = self.generate_hash()
    
  def print_block(self):
    # prints block contents
    print("timestamp:", self.timestamp)
    print("transactions:", self.transactions)
    print("current hash:", self.generate_hash())
    
  def generate_hash(self):
    block_contents = str(self.timestamp) + str(self.transactions) + str(self.previous_hash)
    block_hash = sha256(block_contents.encode())
    return block_hash.hexdigest()

/******************************************************************************************************/

Adding Blocks to the Blockchain
Now that we have everything in place, let’s begin adding blocks to the blockchain.
Instructions
1.
Complete the function add_block().

To do this, create a variable named new_block that takes in a transaction and the previous_block's hash. Append new_block to the end of the chain.


_________________
| blockchain.py |
/******************************************************************************************************/

#imports the Block class from block.py
from block import Block

class Blockchain:
  def __init__(self):
    self.chain = []
    self.all_transactions = []
    self.genesis_block()

  def genesis_block(self):
    transactions = {}
    genesis_block = Block(transactions, "0")
    self.chain.append(genesis_block)
    return self.chain

  # prints contents of blockchain
  def print_blocks(self):
    for i in range(len(self.chain)):
      current_block = self.chain[i]
      print("Block {} {}".format(i, current_block))
      current_block.print_contents()    
  
  # add block to blockchain `chain`
  def add_block(self, transactions):
    previous_block_hash = self.chain[len(self.chain)-1].hash
    new_block = Block(transactions, previous_block_hash)
    self.chain.append(new_block)

/******************************************************************************************************/
_________________
| block.py |
/******************************************************************************************************/

import datetime
from hashlib import sha256

class Block:
  def __init__(self, transactions, previous_hash):
    self.timestamp = datetime.datetime.now()
    self.transactions = transactions
    self.previous_hash = previous_hash
    self.hash = self.generate_hash()
    
  def print_block(self):
    # prints block contents
    print("timestamp:", self.timestamp)
    print("transactions:", self.transactions)
    print("current hash:", self.generate_hash())
    
  def generate_hash(self):
    block_contents = str(self.timestamp) + str(self.transactions) + str(self.previous_hash)
    block_hash = sha256(block_contents.encode())
    return block_hash.hexdigest()

/******************************************************************************************************/


Checking for a Broken Chain
Hashing helps to maintain the integrity of the blockchain. In this exercise, we will see this in action. Let’s write a .validate_chain() method that checks to see if blocks are linked to each other properly.

In order to validate the entire blockchain, we must loop through each of the blocks stored inside the blockchain itself. Then, we will check through each of the blocks to ensure that the previous hash value matches with the hash value inside our previous block.
1.
In the .validate_chain() method, create a for loop with the loop variable i and traverse through the entire length of self.chain. Be sure to start at index 1 instead of index 0.

Inside the for loop, create a variable current and assign it to the current block being indexed with i. Create another variable previous and assign it to the previous block using index i-1.

2.
Verify that the hash of the current block is NOT equal to the value the current block generates via the generate_hash() method. If this condition is true, then the blockchain is not valid, therefore we should return False.
3.
Verify that the hash of the previous hash of the current block is NOT equal to the value generated over the previous block using the generate_hash() method. If this condition is true, then the blockchain is not valid, therefore we should return False.
4.
If the above conditions are not satisfied, then the blockchain is valid! Return True outside the for loop


_________________
| blockchain.py |
/******************************************************************************************************/

#imports the Block class from block.py
from block import Block

class Blockchain:
  def __init__(self):
    self.chain = []
    self.all_transactions = []
    self.genesis_block()

  def genesis_block(self):
    transactions = {}
    genesis_block = Block(transactions, "0")
    self.chain.append(genesis_block)
    return self.chain

  # prints contents of blockchain
  def print_blocks(self):
    for i in range(len(self.chain)):
      current_block = self.chain[i]
      print("Block {} {}".format(i, current_block))
      current_block.print_contents()    
  
  # add block to blockchain `chain`
  def add_block(self, transactions):
    previous_block_hash = self.chain[len(self.chain)-1].hash
    new_block = Block(transactions, previous_block_hash)
    self.chain.append(new_block)

  def validate_chain(self):
    for i in range(1, len(self.chain)):
      current = self.chain[i]
      previous = self.chain[i-1]
      if(current.hash != current.generate_hash()):
        print("The current hash of the block does not equal the generated hash of the block.")
        return False
      if(current.previous_hash != previous.generate_hash()):
        print("The previous block's hash does not equal the previous hash value stored in the current block.")
        return False
    return True

/******************************************************************************************************/


Hacking the Chain
Now we can use the code in our previous exercise to spot a broken link. Let’s try tampering with the contents of the block and see how that creates a mismatch between hash values.
1.
Instantiate a new Blockchain object called my_blockchain.
2.
Add a new block to my_blockchain and pass in new_transactions as the argument.

Print out the contents of my_blockchain to see the new block!

3.
Select the transactions found in my_blockchain's chain attribute. Modify the transactions of the first block setting its value to the string "fake_transactions".

4.
Now let's check if the blockchain is still valid by calling the correct method over my_blockchain!

____________
| script.py |
/******************************************************************************************************/

from blockchain import Blockchain

new_transactions = [{'amount': '30', 'sender':'alice', 'receiver':'bob'},
               	{'amount': '55', 'sender':'bob', 'receiver':'alice'}]


my_blockchain = Blockchain()
my_blockchain.add_block(new_transactions)
my_blockchain.print_blocks()
my_blockchain.chain[1].transactions = 'fake_transactions'
my_blockchain.validate_chain()

/******************************************************************************************************/


Nonce and Proof-of-Work
Let's review the concepts of nonce and proof of work. In this exercise, we will implement an example that demonstrates the difficulty of the math problem that helps protect the blockchain from potential attackers.
1.
Import the sha256 hash function from the Python hashlib library
2.
Create a variable called difficulty and assign it a value of 2. This sets the number of leading zeros that the hash we find must have.

Create another variable called nonce and assign it to a value of 0. This will be our default starting value.
3.
Using the .str() method, cast nonce and new_transactions into strings. Pass the two strings into the sha256 function.

Store the resulting hash value into a variable called proof and print it out!

Note: Use the .hexdigest() method over the resulting sha256 function to properly store the hash value.

4.
Come up with some code that increments the nonce value until the generated hash has difficulty number of leading zeros. Once the desired proof has been found, store it in a variable called final_proof and print it out to see the correct hash!


____________
| script.py |
/******************************************************************************************************/

new_transactions = [{'amount': '30', 'sender':'alice', 'receiver':'bob'},
               	{'amount': '55', 'sender':'bob', 'receiver':'alice'}]

# import sha256
from hashlib import sha256
# sets the amount of leading zeros that must be found in the hash produced by the nonce
difficulty = 2
nonce = 0

# creating the proof 
proof = sha256((str(nonce)+str(new_transactions)).encode()).hexdigest()
# printing proof
print(proof)
  
# finding a proof that has 2 leading zeros
while (proof[:2] != '0' * difficulty):
  nonce += 1
  proof = sha256((str(nonce) + str(new_transactions)).encode()).hexdigest()

# printing final proof that was found
final_proof = proof
print(final_proof)

/******************************************************************************************************/


Implementing Proof-of-Work
Now that we’ve seen a simple example of Proof-of-Work, let’s integrate it into our blockchain! Complete the proof_of_work() method inside the Blockchain class.
1.
Inside the .proof_of_work() method, create a local variable proof and assign it the block's hash.
Stuck? Get a hint
2.
Finish the rest of the method by creating a loop that increments the nonce value until the hash with the required difficulty has been generated.

After finding the correct hash, set the value of the block.nonce back to 0 and return the correct hash outside of the loop.


_________________
| blockchain.py |
/******************************************************************************************************/

#imports the Block class from block.py
from block import Block

class Blockchain:
  def __init__(self):
    self.chain = []
    self.all_transactions = []
    self.genesis_block()

  def genesis_block(self):
    transactions = {}
    genesis_block = Block(transactions, "0")
    self.chain.append(genesis_block)
    return self.chain

  # prints contents of blockchain
  def print_blocks(self):
    for i in range(len(self.chain)):
      current_block = self.chain[i]
      print("Block {} {}".format(i, current_block))
      current_block.print_contents()    
  
  # add block to blockchain `chain`
  def add_block(self, transactions):
    previous_block_hash = self.chain[len(self.chain)-1].hash
    new_block = Block(transactions, previous_block_hash)
    self.chain.append(new_block)

  def validate_chain(self):
    for i in range(1, len(self.chain)):
      current = self.chain[i]
      previous = self.chain[i-1]
      if(current.hash != current.generate_hash()):
        print("The current hash of the block does not equal the generated hash of the block.")
        return False
      if(current.previous_hash != previous.generate_hash()):
        print("The previous block's hash does not equal the previous hash value stored in the current block.")
        return False
    return True
  
  def proof_of_work(self,block, difficulty=2):
    proof = block.generate_hash()
    while proof[:difficulty] != '0'*difficulty:
      block.nonce += 1
      proof = block.generate_hash()
    block.nonce = 0
    return proof

/******************************************************************************************************/

____________
| block.py |
/******************************************************************************************************/

import datetime
from hashlib import sha256

class Block:
  def __init__(self, transactions, previous_hash):
    self.time_stamp = datetime.datetime.now()
    self.transactions = transactions
    self.previous_hash = previous_hash
    self.nonce = 0
    self.hash = self.generate_hash()

  def generate_hash(self):
    block_header = str(self.time_stamp) + str(self.transactions) +str(self.previous_hash) + str(self.nonce)
    block_hash = sha256(block_header.encode())
    return block_hash.hexdigest()

  def print_contents(self):
    print("timestamp:", self.time_stamp)
    print("transactions:", self.transactions)
    print("current hash:", self.generate_hash())
    print("previous hash:", self.previous_hash) 

/******************************************************************************************************/


Adding Blocks to the Chain Securely
Now that we have implemented our Proof-of-Work method, we can now work on adding new blocks securely.
1.
In the .add_block() method, calculate the proof_of_work for the new_block. Assign the calculated proof_of_work to a variable named proof before appending the new_block to the blockchain.

Return, in order, the calculated proof and the new_block itself.


_________________
| blockchain.py |
/******************************************************************************************************/

from block import Block

class Blockchain:
  def __init__(self):
    self.chain = []
    self.unconfirmed_transactions = []
    self.genesis_block()

  def genesis_block(self):
    transactions = []
    genesis_block = Block(transactions, "0")
    genesis_block.generate_hash()
    self.chain.append(genesis_block)

  def add_block(self, transactions):
    previous_hash = (self.chain[len(self.chain)-1]).hash
    new_block = Block(transactions, previous_hash)
    new_block.generate_hash()
    proof = self.proof_of_work(new_block)
    self.chain.append(new_block)
    return proof, new_block

  def print_blocks(self):
    for i in range(len(self.chain)):
      current_block = self.chain[i]
      print("Block {} {}".format(i, current_block))
      current_block.print_contents()

  def validate_chain(self):
    for i in range(1, len(self.chain)):
      current = self.chain[i]
      previous = self.chain[i-1]
      if(current.hash != current.generate_hash()):
        print("The current hash of the block does not equal the generated hash of the block.")
        return False
      if(current.previous_hash != previous.generate_hash()):
        print("The previous block's hash does not equal the previous hash value stored in the current block.")
        return False
    return True
  
  def proof_of_work(self,block, difficulty=2):
    proof = block.generate_hash()
    while proof[:difficulty] != '0'*difficulty:
      block.nonce += 1
      proof = block.generate_hash()
    block.nonce = 0
    return proof

/******************************************************************************************************/


Blockchain Summary
Congratulations! You have completed all the steps required to build a basic blockchain! In this exercise, we will bring the key parts together to review what we have built so far.

Note: The blockchain we have built only exists on a local machine. It is important to know that actual blockchain applications operate on multiple computers in a decentralized manner.
1.
Create a Blockchain object named local_blockchain. Verify that this automatically creates a Genesis Block by printing out the contents of local_blockchain.

2.
Individually add block_one_transactions, block_two_transactions, and block_three_transactions respectively into local_blockchain. Print out the contents of local_blockchain to see what the block holds.

3.
Modify the second block you added in local_blockchain by changing the block's transactions to fake_transactions. Check to see if the blockchain is still valid using the correct method.


_____________
| script.py |
/******************************************************************************************************/

from blockchain import Blockchain

block_one_transactions = {"sender":"Alice", "receiver": "Bob", "amount":"50"}
block_two_transactions = {"sender": "Bob", "receiver":"Cole", "amount":"25"}
block_three_transactions = {"sender":"Alice", "receiver":"Cole", "amount":"35"}
fake_transactions = {"sender": "Bob", "receiver":"Cole, Alice", "amount":"25"}

local_blockchain = Blockchain()
local_blockchain.print_blocks()

local_blockchain.add_block(block_one_transactions)
local_blockchain.add_block(block_two_transactions)
local_blockchain.add_block(block_three_transactions)
local_blockchain.print_blocks()
local_blockchain.chain[2].transactions = fake_transactions
local_blockchain.validate_chain()

/******************************************************************************************************/

